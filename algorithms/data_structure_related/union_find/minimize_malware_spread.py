from union_find import UnionFind

# Minimize Malware Spread
# We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).
class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        if not initial:
            return -1
        # return the smallest index if multiple results
        initial.sort()
        n = len(graph)
        uf = UnionFind(n)
        # union the whole graph
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j] == 1:
                    uf.union(i, j)
        # if only one initially infected node, the damage reduced will be the group size
        # => return the infected node in the largest group
        # if 2+ initially infected node in a group, cannot reduce the damage
        # => return the infected node with minimum index
        counter = collections.Counter(uf.find(i) for i in initial)  # group_parent => # of initially infected nodes
        one_infected = [i for i in initial if counter[uf.find(i)] == 1]
        if one_infected:
            return max(one_infected, key=lambda i: uf.sizes[uf.find(i)])
        else:
            return min(initial)
# O(n ^ 2) time, O(n) space


# Minimize Malware Spread II
# In this case, we will remove one node from the initial list, completely removing it and any connections
# from this node to any other node. Return the node that if removed, would minimize M(initial).
class SolutionQ2(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        n = len(graph)
        d = collections.defaultdict(list)  # node => list of initiail nodes

        for init in initial:
            # find reachable nodes if other initial nodes are cut off
            visited = set(initial)
            queue = collections.deque([init])
            while queue:
                infected = queue.popleft()
                for node in range(n):
                    if graph[infected][node] and node not in visited:
                        visited.add(node)
                        d[node].append(init)
                        queue.append(node)

        # for node i, how many initial nodes can infected it
        # without going through other initial nodes
        connected = [0] * n
        for node, src_nodes in d.items():
            if len(src_nodes) == 1:
                init = src_nodes[0]
                connected[init] += 1

        max_connected = max(connected)
        if max_connected == 0:
            return min(initial)
        return connected.index(max_connected)
# thought process:
# if multiple nodes can infect a node N without going through other initial nodes
# then removing one initial node would not save node N
